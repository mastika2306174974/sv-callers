import os
import sys

from snakemake import load_configfile
from csv import DictReader

config = load_configfile('analysis.yaml')


def get_callers():
    """Get a list of SV callers enabled by a user.
    :returns: (list) of selected SV callers
    """
    callers = []
    for c in config["enable_callers"]:
        if c not in config["callers"]:
            raise AssertionError("SV caller '{}' is not supported!".format(c))
        callers.append(c)
    return callers


def get_filext(fmt):
    """Get file extension(s) given file type/format:
        ['fasta', 'fasta_idx', 'bam', 'bam_idx', 'vcf', 'bcf', 'bed']
    :param fmt: (str) input file format
    :returns: (str) file extension
    """
    if fmt not in config["file_exts"].keys():
        raise AssertionError("Unknown input file format '{}'.".format(fmt.lower()))
    return config["file_exts"][fmt]


def get_fasta():
    """Get reference genome in FASTA format.
    :returns: filepath
    """
    fname = config["genome"]
    sfx = get_filext("fasta")
    try:
        if not os.path.exists(fname):
            raise AssertionError("FASTA file not found: {}.".format(fname))
        if not fname.endswith(sfx):
            raise AssertionError("FASTA file '{}' (extension) not registered.".format(fname))
    except AssertionError as err:
        print(str(err), file=sys.stderr)
        os._exit(1)
    return fname


def get_faidx():
    """Get FASTA index files generated by faidx and bwa tools.
    :returns: (list) filepaths
    """
    faidx = []
    for sfx in get_filext("fasta_idx"):
        fname = get_fasta().split(get_filext("fasta"))[0] + sfx
        try:
            if not os.path.exists(fname):
                raise AssertionError("FASTA index file not found: {}.".format(fname))
        except AssertionError as err:
            print(str(err), file=sys.stderr)
            os._exit(1)
        faidx.append(fname)
    return faidx


def exclude_regions():
    """Use an exclusion list of genomic regions in BED format.
    :returns: (int) flag 1=yes, 0=no
    """
    flag = config["exclude_regions"]
    try:
        if flag not in (0, 1):
            raise AssertionError("Invalid value: 'exclude_regions' must be either 0 or 1.")
    except AssertionError as err:
        print(str(err), file=sys.stderr)
        os._exit(1)
    return flag


def get_bed():
    """Get the exclusion file in BED format.
    :returns: (str) filepath
    """
    fname = config["exclusion_list"]
    sfx = get_filext("bed")
    try:
        if not os.path.exists(fname):
            raise AssertionError("Exclusion file not found: {}.".format(fname))
        if not fname.endswith(sfx):
            raise AssertionError("Exclusion file '{}' must end with '{}' suffix.".format(fname, sfx))
    except AssertionError as err:
        print(str(err), file=sys.stderr)
        os._exit(1)
    return fname


def get_bam(sample):
    """Get the sample in BAM format.
    :param sample: (str) sample name
    :returns: (str) filepath
    """
    sfx = get_filext("bam")
    if sample.endswith(sfx) is False:
        sample += sfx
    return sample


def get_bai(sample):
    """Get the index of sample in BAI format.
    :param sample: (str) sample name
    :returns: (str) filepath
    """
    sfx = get_filext("bam_idx")
    if sample.endswith(sfx) is False:
        sample += sfx
    return sample


def get_outdir(caller):
    """Get the caller's output directory.
    :param caller: (str) SV caller
    :returns: (str) outdir relative to sample dir
    """
    return config["callers"][caller]["outdir"]


def get_nthreads(tool):
    """Get the number of threads requested by a tool.
    :param tool: (str) SV detection or post-processing tool
    :returns: (int) number of threads (default: 1)
    """
    try:
        if "survivor" in tool:
            return config["postproc"][tool]["threads"]
        else:
            return config["callers"][tool]["threads"]
    except:
        return 1


def get_memory(tool):
    """Get the amount of memory requested by a tool.
    :param tool: (str) SV detection or post-processing tool
    :returns: (int) memory used in MB (default: 1024)
    """
    try:
        if "survivor" in tool:
            return config["postproc"][tool]["memory"]
        else:
            return config["callers"][tool]["memory"]
    except:
        return 1024


def get_tmpspace(tool):
    """Get the amount of temporary disk space requested by a tool.
    :param tool: (str) SV detection or post-processing tool
    :returns: (int) disk space used in MB (default: 0)
    """
    try:
        if "survivor" in config["callers"][tool]:
            return config["postproc"][tool]["tmpspace"]
        else:
            return config["callers"][tool]["tmpspace"]
    except:
        return 0


def is_tumor_only():
    """Perform tumor-only or germline analysis using Manta.
    :returns: (int) flag 1=yes, 0=no
    """
    flag = config["callers"]["manta"]["tumor_only"]
    try:
        if flag not in (0, 1):
            raise AssertionError("Incorrect value for Manta 'tumor_only': must be either 0 or 1.")
    except AssertionError as err:
        print(str(err), file=sys.stderr)
        os._exit(1)
    return flag


def survivor_args(c):
    """Get user-defined parameters for SURVIVOR command.
    :param c: sub-command 'filter' or 'merge'
    :returns: (list) arguments or values
    """
    try:
        if c not in ("filter", "merge"):
            raise AssertionError("Incorrect SURVIVOR sub-command: must be either 'filter' or 'merge'.")
    except AssertionError as err:
        print(str(err), file=sys.stderr)
        os._exit(1)

    args = []
    p = config["postproc"]["survivor"][c]
    if c in "filter":
        args = ['"%s"' % get_bed(), p["min_size"], p["max_size"], p["min_freq"],
                p["min_sup"]]
    else:
        args = [p["infile"], p["max_dist"], p["min_sup"], p["use_type"],
                p["use_strand"], p["use_size"], p["min_size"], p["outfile"]]
    return args


def make_output():
    """Generate workflow targets: outfiles of different callers in VCF format.
    :returns: (list) filepaths in this form:
        PATH/SAMPLE1[--SAMPLE2]/CALLER_OUTDIR/*.vcf according to the config files
    """
    def is_ok(s):
        if s in (None, ""):
            return False
        return s

    with open(config["samples"], "r") as fp:
        mode = config["mode"]
        try:
            if mode not in ('s', 'p'):
                raise AssertionError("Invalid workflow mode: run (s)ingle- or (p)aired-samples analysis.")
        except AssertionError as err:
            print(str(err), file=sys.stderr)
            os._exit(1)

        reader = DictReader(line for line in fp if not line.startswith("#"))
        outfiles = []
        for i, r in enumerate(reader):
            try:
                path = os.path.join(r["PATH"], is_ok(r["SAMPLE1"]))
                if mode.startswith('p') is True:  # for paired-samples
                    path += "--" + is_ok(r["SAMPLE2"])
            except TypeError as err:
                print("Missing value(s) in '{}' at record #{}: {}"
                      .format(config["samples"], i + 1, list(r.values())),
                      file=sys.stderr)
                os._exit(1)

            for c in get_callers():
                vcf = c + get_filext("vcf")
                vcf = os.path.join(path, get_outdir(c), "survivor", vcf)
                outfiles.append(vcf)
        return outfiles


def make_all():
    """Generate workflow targets: outfiles of merged SV calls in VCF format.
    :returns: (list) filepaths in this form:
        PATH/SAMPLE1[--SAMPLE2]/*.vcf according to the config files
    """
    outfiles = []
    basename = survivor_args("merge")[-1]
    for f in make_output():
        path = os.path.join(os.sep.join(f.split(os.sep)[:-3]), basename)
        outfiles.append(path)
    return set(outfiles)
